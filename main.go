package main

import (
	"fmt"

	"github.com/isfk/protoc-gen-go-topics/proto/topics"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(
		func(plugin *protogen.Plugin) error {
			plugin.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
			for _, file := range plugin.Files {
				if file.Generate {
					generateTopics(plugin, file)
				}
			}
			return nil
		},
	)
}

func generateTopics(plugin *protogen.Plugin, file *protogen.File) {
	fops := proto.GetExtension(file.Desc.Options(), topics.E_FileTopic).(topics.Topic)
	if fops == topics.Topic_TOPIC_TRUE {
		filename := file.GeneratedFilenamePrefix + ".topics.go"
		g := plugin.NewGeneratedFile(filename, file.GoImportPath)
		g.P("// Code generated by protoc-gen-go-topics. DO NOT EDIT.")
		g.P()
		g.P("package ", file.GoPackageName)
		g.P()
		g.P("const (")
		for _, service := range file.Services {
			for _, method := range service.Methods {
				mops := proto.GetExtension(method.Desc.Options(), topics.E_MethodTopic).(topics.Topic)
				if mops == topics.Topic_TOPIC_TRUE {
					topic := fmt.Sprintf("%s_%s_Topic = \"%v.%v\"", service.Desc.Name(), method.Desc.Name(), service.Desc.FullName(), method.Desc.Name())
					g.P(topic)
				}
			}
		}
		g.P(")")
	}
}
